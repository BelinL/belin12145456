---
layout:     post
title:      我认识的数据库事务与分布式事务
subtitle:   数据库事务、分布式事务的理解以及它们的区别
date:       2019-12-17
author:     Belin
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - ACID
    - 事务
    - 分布式事务
---

# 理论基础
## 概念
事务是数据非常重要的概念，提到事务第一个想到的就是它的原子性：事务中的所有操作要么全部执行，要么全不执行。
一个常识性的问题：无论数据库是否支持事务，数据库DML（Select、Insert、Update、Delete）的执行结果只有两个：成功与失败。
这是单独对表的某些数据而言的，是数据库提供给用户基础操作粒度，若用户需要在多个数据的基础上也具有这个特性* 即多个修改的数据要么全部修改成功要么全部不修改（修改失败）*，
这就需要使用事务了。事务提供了比数据库DML更高层的一个逻辑单元，是在用户层面的可自定义的逻辑单元，用户可以在事务中加入任何操作，加入的所有操作具有一个
整体的原子性，这是事务的一个基本的认识。除了原子性之外，事务还具有其他三个特性：一致性、隔离性和持久性，四个合一块简称ACID。不要问为啥还有其他，因为它叫事务。  
若把数据库单纯看成数据，把事务的数据修改、变换看成是处理逻辑，那事务的执行过程可以看成面向过程的过程:  
![transaction](/img/post-bg-transaction-flow.jpg)  
那么事务就是将数据库从一个数据状态转换成另一个数据状态，每一个状态中的数据都保持一致性。
## ACID特性
### 原子性(Atomicity)  
> 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态；

 
原子性比较好理解，不做过多的解析了。
### 一致性(Consistency)
> 事务执行前与执行后都必须始终保持系统处于一致的状态  

一致性可以理解成为事务前后的规则一致和数据的一致。  
规则一致性是指数据的完整性约束，包括主键约束、引用约束等，事务前后不会破坏这些规则；  
数据一致性是指应用层面的一致，更多的依赖于用户的正确的逻辑，比如转账前后总额不变，事务在一定程度上提供了数据的一致性特性。  
### 隔离性(Isolation)
> 又名并发控制，指在一个事务调度期间，不同事务对同一个数据对象的操作在事务期间是分开的、隔离的，这需要通过某种技术手段实现，比如锁。并发事务之间不会相互干扰，彼此独立执行

隔离性其实是在并发情况下所体现的特性，若应用层不存在并发，隔离性基本上不会被感觉到，当然这是不可能的。
多个事务并发运行的场景下，会引发和多线程编程资源竞争类似的问题，比如对同一数据的读写时，若不加以控制事务可能读取到脏数据、旧数据的情况。  
使用不同的隔离级别来处理这类问题：*按序号顺序随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降*
- 1、`RAED UNCOMMITED`   : 使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；会出现脏读、不可重复读、幻读
- 2、`READ COMMITED`     : 只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；会出现不可重复读、幻读
- 3、`REPEATABLE READ`   : 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；
- 4、`SERIALIZABLE`      : 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题。  

不同隔离级别下可能出现的问题如下：

| | 脏读 | 不可重复读 | 幻读 |  
|---|:---:|:---:|:---:|
| RAED UNCOMMITED（读未提交） | Yes | Yes | Yes |
| READ COMMITED（读提交） | No | Yes | Yes |
| REPEATABLE READ（可重复读） | No | No | Yes |
| SERIALIZABLE（串行）| No | No | No |  

#### 脏读(RAED UNCOMMITED)  
> 在一个事务中，读取了其他事务未提交的数据。  
> 从事务调度看，存在write-read操作序列时即出现脏读。

出现场景：
> 锁分析：事务2在对其使用的数据加共享锁（直到事务结束），而这期间事务1可对数据进行读取造成脏读。

| |事务1|事务2|
|---|:---|:---|
|1、| |UPDATE table_x VALUES(x) WHERE id = 1|
|2、|SELECT * FROM table_x WHERE id = 1| |
|3、|COMMIT|ROLLBACK|  

在第3步时可能读取到未提交的数据，隔离级别`READ COMMITED`、`REPEATABLE READ`、`SERIALIZABLE`都可以有效地解决了脏读问题。

#### 不可重复读(READ COMMITED)
> 在一个事务中，同一行记录被访问了两次却得到了不同的结果。  
> 从事务调度看，存在read-write操作序列时可能出现出现不可重复读。

出现场景：
一般出现在一个事务的两次读取中间有其他事务提交了数据修改、删除：

> 1、事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据）。  
> 2、事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）  
> 3、事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）  

| |事务1|事务2|
|---|:---|:---|
|1、|SELECT * FROM table_x WHERE id = 1| |
|2、| |UPDATE table_x SET x = x WHERE id = 1|
|3、| |COMMIT|
|4、|SELECT * FROM table_x WHERE id = 1| |
|5、|COMMIT| |  

在第1步和第4步读取到的数据可能不一致，出现同一个事务内对表记录的两个读取结果不相同，隔离级别`REPEATABLE READ`、`SERIALIZABLE`都可以有效地解决了不可重复读问题。INSERT INTO table_x VALUES(x)

#### 幻读(REPEATABLE READ)
> 在一个事务中，对指定的某一范围（where条件的数据进行前后两次访问却得到了数量不同的结果。  
> 从事务调度看，存在read-write操作序列时可能出现出现幻读。 

出现场景：
一般出现在一个事务的两次读取中间有其他事务提交了数据新增：

> 1、事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据）。  
> 2、事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）  
> 3、事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）   

| |事务1|事务2|  
|---|:---|:---|  
|1、|SELECT * FROM table_x| |  
|2、| |INSERT INTO table_x VALUES(x)|  
|3、| |COMMIT|  
|4、|SELECT * FROM table_x| |  
|5、|COMMIT| |  

在第1步和第4步读取到的数据数可能不一致，出现同一个事务内对表记录的两个读取结果不相同，隔离级别、`SERIALIZABLE`都可以有效地解决了不可重复读问题。

#### 串行化(SERIALIZABLE)
> 1、事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）  
> 2、事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。（事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）

### 持久性(Durability)
> 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中。

对于已提交的事务的数据，数据库将保存最后一次更新到存储介质中，属于物理操作。若事务执行到一半宕机，在重启数据库时数据库将会恢复数据对象到事务前的状态，即回滚未完成的事务。

## 数据库特性实现原理
###原子性  
事务的原子性即整个事务作为一个操作单元，在事务结束时要么全部操作执行成功要么全部操作撤销。这是通过数据库操作日志实现，数据库在运行过程中对增删改操作进行日志记录，
原子性相关日志称为UNDO日志（数据库只有一个日志，可能因为容易理解查会有多种称呼）；当需要撤销操作时（回滚），从日志回溯相关操作即可将数据对象恢复到事务前的状态。

### 一致性

// todo

### 隔离性
隔离性即并发控制，数据库实现隔离性一般分为两种  
- 基于锁的实现-`Lock based protocols`:在并发事务之间通过锁控制数据对象的访问权限，从而避免并发事务同时访问相同数据对象的情况，属于串行运行思想的解决方案；
- 基于时间戳的实现-`Time stamp based protocols`:通过对事务和数据对象添加时间戳进行控制，通过对比时间戳控制数据兑现的访问，也属于串行运行思想的解决方案。

#### Lock based protocols
一般来说，数据库是用的锁都是 共享锁(Shared)/排他锁(exclusive)：
共享锁：即读锁，可被多个事务同时持有，共享数据对象；
排它锁：即写锁，是独占锁，事务持有某数据对象的排他锁时其他事务无法获取其共享锁、排他锁。

锁的使用有一定的规则协议：两阶段封锁协议、三级封锁封锁协议
##### 两阶段封锁协议
`Two-Phase Locking 2PL`,将事务执行过程划分为两个阶段：  
第一阶段是事务获取锁的阶段，在这个阶段中事务持有锁的数量呈现增长状态，当获取到所有锁时，称为封锁点；  
第二阶段是事务释放锁阶段，在这个阶段中事务持有锁的数量呈现减少状态，当获开始解锁事务持有的任何一个锁时，称为解锁点。  
通两个阶段加锁解锁，能保证释放锁是在获取到所有锁的前提下进行的，即事务执行操作过程持有所有锁，从而保证并发调度的正确性。

严格两阶段封锁协议: 除了要求封锁是两阶段之外，还要求事务持有的所有排它锁必须在事务提交之后方可释放。这个要求保证未提交事务所写的任何数据，在该事务提交之前均以排它锁封锁，防止其他事务读取这些数据。
强两阶段封锁协议: 要求事务提交之前不得释放任何锁。使用锁机制的数据库系统，要么使用严格两阶段封锁协议，要么使用强两阶段封锁协议。

> 如果事务的每个READ、WRITE、UNLOCK都被相应的锁覆盖，且所有的锁都是在事务结束时释放，那么称这样的事务是`规范`的
> 如果衣蛾事务可以分成两个阶段，只请求封锁的扩展阶段和只释放锁的收缩阶段，那么称这样的事务是`两段式`的

##### 三级封锁协议
- 1、`RAED UNCOMMITED`   : 对修改数据添加`排他锁`直到事务结束，对读取不加锁；`该级别封锁协议对排他锁是两段的，对写操作是规范的`
- 2、`READ COMMITED`     : 事务在更新数据时先对其数据添加`排他锁`直到事务结束，在读取数据时先对其数据添加`共享锁`且读取完就释放锁；`该协议是规范的（读写都有所覆盖），对排他锁是两阶段的`
- 3、`REPEATABLE READ`   : 事务在更新数据时先对其数据添加`排他锁`直到事务结束，在读取数据时先对其数据添加`共享锁`直到事务结束；`该协议是规范的（读写都有所覆盖），对排他锁是两阶段的`
- 4、`SERIALIZABLE`      : 事务在更新数据时先对其数据添加`表级排他锁`直到事务结束，在读取数据时先对其数据添加`表级共享锁`直到事务结束。`该协议是两阶段的且规范的`

三级封锁协议级别越高并发安全性越高，而性能越差，这需要实际场景进行安全和性能权衡取舍。另一方面，固然能保证事务并发调度的正确性，然而依然会出现`死锁`问题，需要算法处理：`wait-die`策略、`wound-wait`策略  

#### Timestamp-based Protocols
广泛使用的基于时间戳的并发控制协议，协议使用系统时间或者计数器作为时间戳。在基于锁的协议中，事务的执行顺序往往在冲突发生时才决定顺序，即多个事务同时访问同一数据时才决定给哪个事务先用哪个事务后使用，
而基于时间的协议则是在事务开始运行时就已经决定了。  
协议中每一个事务都有一个时间戳，在事务开始运行时获取（分配）的，只要保证并发运行的事务时间戳不同，即可使用时间戳的新老顺序进行排序运行。同时，数据库中的`数据对象`也会带上两个时间戳，即最后访问一次（读写）的事务的
时间戳，读时间戳、写时间戳。  
定义：
- TS(Ti)为事务Ti的时间戳;
- RTS(X)为数据对象X的读时间戳;
- WTS(X)为数据对象X的写时间戳

则时间戳排序协议遵循以下规则：
- 当事务进行一个`读操作`时，有
 1.如果当前事务比`数据写`老，即 TS(Ti) < WTS(X)
  则拒绝读操作（这里强调的思想是如果有其他年轻事务修改过这个值，那么就不能读。）
 2.如果当前事务比`数据写`年轻，即 TS(Ti) >= WTS(X)
  则事务正常读取数据。 

> 事务只能读取数据写比自己老的数据，即当前事务运行之前就已经修改的数据。  

- 当事务进行一个`写操作`时，有
 1.如果当前事务比`数据读`老，即 TS(Ti) < RTS(X)
   则拒绝写操作
 2.如果当前事务比`数据写`老，即 TS(Ti) < WTS(X)
   则拒绝写操作并回滚事务

> 事务修改数据时必须保证在该数据对象上进行过读和写操作的事务中（包含当前事务）的都是最晚的一个

#### mysql中的实现


# Java中的应用

# Reference  
[数据库事务隔离级别和锁实现机制](https://www.iteye.com/blog/comedsh-698733)  
[深入分析事务的隔离级别](https://www.hollischuang.com/archives/943)  